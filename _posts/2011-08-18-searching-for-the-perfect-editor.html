---
layout: post
status: publish
published: true
title: Searching for the perfect editor
author:
  display_name: eliot
  login: eliot
  email: fadookie@gmail.com
  url: ''
author_login: eliot
author_email: fadookie@gmail.com
wordpress_id: 383
wordpress_url: http://www.eliotlash.com/?p=383
date: '2011-08-18 10:46:34 +0000'
date_gmt: '2011-08-18 17:46:34 +0000'
categories:
- Tools
tags:
- editor
- vim
- emacs
comments:
- id: 11
  author: Mauvis Ledford
  author_email: switchstatement@gmail.com
  author_url: http://www.readystate4.com
  date: '2011-08-18 14:30:46 +0000'
  date_gmt: '2011-08-18 21:30:46 +0000'
  content: "Great post Eliot!\r\n\r\nI would say, though, that under your Rubic Table
    that Emacs should be listed as highly assistive. Out of the box, the first page
    that loads is an introduction that links off to the Emacs tutorial and a guided
    tour - that will have you mastering the basics in no time. \r\n\r\nIn addition
    you quickly learn things like M-x aprops [string] to do a search of all commands
    for a word if you can't remember a command.  M-x describe-key [key command] if
    you want to know what a certain key command you are running is actually doing.
    As well as a ton of others helpful introspective commands.\r\n\r\nI just realized
    something recently about the Vim / Emacs debate  (that will undoubtedly go on
    until the end of time.) I've been an Emacs user for a few years now and through
    every job, no matter what back or front-end languages involved, what compiling
    processes are required, whether it's on remote or local dev machines, whether
    it's on Unix or Mac machines - I have been incredibly efficient with Emacs. The
    thing is, I always here \"Vim can do that\" from Vim users, but when I it finally
    gets down to \"Do you use it at work?\", on more than one occasion I have gotten
    this answer: \"Oh, no, I use [Eclipse / intellij / other massive GUI editor].\""
- id: 12
  author: eliot
  author_email: fadookie@gmail.com
  author_url: ''
  date: '2011-08-18 14:35:50 +0000'
  date_gmt: '2011-08-18 21:35:50 +0000'
  content: "Thanks for your input, I'm interested to see what Emacs users think.\r\n\r\nHowever,
    I had something very specific in mind for my criteria of being \"assistive,\"
    that  \"a code editor should provide facilities for code completion and inline
    display of documentation relevant to the code being written.\" What I meant is
    intellisense-style code completion and display of inline documentation for YOUR
    code and classes. I.e. if I define a class \"Foo\" with some instance method \"bar\",
    when I type\r\n<code>foo = new Foo();\r\nfoo.</code>\r\nand hit the completion
    key, \"bar\" should come up as an option. Also, if I have defined documentation
    for my instance method, i.e. what it does and an explanation of what the arguments
    are, those should also be easy for me to view inline as I am editing, by some
    sort of pop-up tooltip or something like that. This is a feature provided by most
    modern IDEs, but only for a small subset of supported languages.\r\n\r\nMy understanding
    is that, at least for the completion bit, this functionality is achievable in
    Vim through reading a tags file generated by running exuberant ctags against my
    own codebase periodically. Correct me if I'm wrong, but I think that Emacs also
    requires exuberant ctags to be set up to provide that level of completion for
    a variety of popular languages such as PHP, Java, etc. I should also revise my
    definition to include jumping to declarations and definitions of symbols, another
    IDE feature I miss sorely when using pure Vim sans ctags.\r\n\r\nIn this case
    I'm actually arguing against the \"Vim can do it\" argument - Vim *can* be assistive
    by my definition, but it's so much of a pain that nobody I know, including myself,
    has ever bothered to set it up and use it at work. I've recently been using a
    mix between Vim running on our dev box, and the jVi plugin in NetBeans to do my
    editing, which supports 99% of the Vim commands I use as well as NetBeans's built-in
    assistive features for PHP and Java. However this setup would be useless for a
    language not supported by NetBeans. I also kind of hate NetBeans, it's a memory
    hog and periodically hangs."
- id: 13
  author: eliot
  author_email: fadookie@gmail.com
  author_url: ''
  date: '2011-08-18 15:33:16 +0000'
  date_gmt: '2011-08-18 22:33:16 +0000'
  content: "I did a bit of Googling to check my claim about Emacs completion features,
    etc. Let me know if you can make heads or tails of <a href=\"http://www.emacswiki.org/emacs/CategoryCompletion#toc3\"
    rel=\"nofollow\">this wiki page</a> or <a href=\"http://tulrich.com/geekstuff/emacs.html\"
    rel=\"nofollow\">this guy's notes on various tag solutions</a>.\r\n\r\nIf there
    actually is a good and easy way to get the sort of assistive features I described
    above working in Emacs for a relevant slice of popular languages, in a practical
    \"do you use it at work\" way please let me know and I will check it out. I based
    my claim partially off of reading stuff on blogs and also asking Emacs users I
    know if they use assistive features I described 'at work,' the answer I got was
    no. I guess I can always give <a href=\"http://www.emacswiki.org/emacs/ViperMode\"
    rel=\"nofollow\">viper-mode</a>/<a href=\"http://www.emacswiki.org/emacs-es/Vimpulse\"
    rel=\"nofollow\">Vimpulse</a> a shot. :)"
- id: 438
  author: Jason
  author_email: jasonm23@gmail.com
  author_url: http://jasonm23.github.com
  date: '2013-01-05 06:22:34 +0000'
  date_gmt: '2013-01-05 14:22:34 +0000'
  content: "I have an Emacs starter kit (of sorts) and I'd love to see how you go
    with it if you try it out. In a nutshell I've tried to bring it up to scratch
    as a modern editing environment, so it has things like CUA (Ctrl-x,c,v cut/copy/paste)
    (Ctrl-z undo) as basic helpers for transitioning from TextMate and everything
    else that isn't Vim or Emacs.\r\n\r\nIn addition there are assistive features,
    an extensive set of YaSnippets for several languages, and a newish library called
    AutoComplete, which offers dropdown completion similar to that found in modern
    IDE's. Now, don't get carried away, an ide specifically tailored to a language
    is going to have the best auto-completion available, but AutoComplete is a very
    good addition to Emacs.\r\n\r\nAs well as that, the usual autocomplete/abbreviation
    expansion stuff in Emacs is bound to Alt-/ and Super -/  (Cmd on mac, needs to
    be mapped on other platforms.) This will autocomplete filenames and any string
    in an open buffer, as well as any known words for the current editing mode.\r\n\r\nAnyway,
    what my starter kit most notably does, is not shove Emacs down your throat, and
    tries to make it as accessible as possible, (if you want to unbind cursors, you
    can do that yourself, but I'd suggest learning to navigate with C-s C-r instead,
    if you really want to improve your editing speeds.)\r\n\r\nOther starter kits
    want to admonish you for not already being an Emacs devotee... which to me is
    the most wrong headed approach. Mine on the other hand is meant to show you it
    can stomp any other general textediting software, with it's eyes closed.\r\n\r\nGive
    it a try. \r\n\r\nhttps://github.com/ocodo/emacs.d \r\n\r\n(Note: has a fair bit
    of Os X specificity and is designed to work with Emacs24.)"
- id: 44530
  author: site official
  author_email: enriquevirgin@live.com
  author_url: http://www.golfzonsimulator.com/
  date: '2016-01-06 14:30:00 +0000'
  date_gmt: '2016-01-06 22:30:00 +0000'
  content: "Hello mates, its enormous piece of writing regarding cultureand completely
    \r\ndefined, keep it up all the time."
- id: 45435
  author: XYDWilfredo
  author_email: etsukofrizzell@live.de
  author_url: http://facebook.com/India
  date: '2016-04-12 20:01:40 +0000'
  date_gmt: '2016-04-13 03:01:40 +0000'
  content: "I see, that your website needs unique and fresh content.\r\nI know it
    is hard to write content manually everyday, but there is solution for this.\r\nJust
    search in g00gle for: Atonemen's tips"
---
<p>Text editors. Yawn. Who cares? It's just text!</p>
<p>For many people, it really doesn't make a difference. But I'm a programmer. I edit code for a living. My editor is the tool of my trade and I want to use the most efficient tool available.</p>
<p style="text-align: center;"><a href="http://tnerual.eriogerg.free.fr/0xBABAF000L/10_en.html"><img class="aligncenter" title="Emacs vs Vi, taken from 0xBABAF000L" src="http://eliot.s3.amazonaws.com/eliotlash.com/0010_en_vi-vs-emacs.png" alt="" width="800" height="254" /></a></p>
<p>I'd be preaching to the choir if I was telling programmers that they should use good text editors. But I've noticed some patterns in the history of text editors I've used that have made me come up with my own philosophy about choosing an editor. My goals and usage habits are certainly not the same as everyone else's, but I hope that in sharing them I might get you to reflect on your own habits and see if they match up to your goals.</p>
<p><!--more--></p>
<p>I have used many different text editors over the years, starting with the crappy built-in editor for&nbsp;<a href="http://en.wikipedia.org/wiki/IBM_BASICA">BASICA</a>.&nbsp;I've used&nbsp;<a href="http://en.wikipedia.org/wiki/Notepad_(software)">Notepad</a>, <a href="http://liquidninja.com/metapad/">Metapad</a>, <a href="http://en.wikipedia.org/wiki/Pico_(text_editor)">Pico</a>/<a href="http://www.nano-editor.org/">Nano</a>, <a href="http://en.wikipedia.org/wiki/TextEdit">TextEdit</a>, <a href="http://www.codingmonkeys.de/subethaedit/">SubEthaEdit</a>,&nbsp;<a href="http://www.barebones.com/products/bbedit/">BBEdit</a>/<a href="http://www.barebones.com/products/textwrangler/">TextWrangler</a>, <a href="http://notepad-plus-plus.org/">Notepad++</a>, <a href="http://www.vim.org/">Vim</a>, <a href="http://www.microsoft.com/visualstudio/en-us">Visual Studio</a>, and <a href="http://netbeans.org/">NetBeans</a> to name a few. My reasons for switching (or using more than one editor) were various. I was moving to a different OS, or using multiple OSes. I found an editor with a cooler feature set than my current one and I wanted to check it out. The editor was&nbsp;recommended&nbsp;to me by a friend or teacher. I was learning a new programming language that was highly IDE-centric (like C# and Java) and it made sense to adopt a respective IDE.</p>
<p>I noticed something making all of these jumps between editors. There's a friction that occurs when switching, a penalty. When I had been using my previous editor I was developing muscle memory from repeated use of certain keystrokes to perform a task. In my next editor I'd habitually hit whatever key I was using in my previous editor for find, find and replace, save, copy, etc. This annoyed me a bit as I had to spend a good amount of time re-training my reflexes to use different keys, to get back up to the speed and subconscious efficiency I had in my previous editor. I began realizing that it was counterproductive to my efficiency to keep switching editors every couple of years. It made sense to pick one editor as my main editor and stick to it so I could <strong>retain and build off my muscle memory, a valuable byproduct of using the same editor </strong>for a long time. Muscle memory is valuable because it allows our conscious mind to think of an action, but our reflexes to execute it instantly. It can only be acquired through repetitions of an action.</p>
<blockquote><p>... This phenomenon is sometimes called "muscle memory", a phrase that tellingly gives credit to an organ other than the brain. The brain is really in charge, of course, but the term rings true because the actions seem to happen without conscious thought. This is the ultimate in efficiency, leaving the higher-functioning parts of the brain free to concentrate on the task, rather than on the operation of the tool required to complete the task.</p>
<p>-<a href="http://arstechnica.com/apple/reviews/2003/04/finder.ars/4">John Siracusa</a></p></blockquote>
<p>Somewhere along the line, somebody suggested I check out Vim, an improved version of the Vi editor. I ran my own Linux server so I was slightly familiar with Vi, as is any Unix user (it has a way of popping up from time to time since it's the default editor.) I knew one command, how to quit it! I found this arcane, cryptic editor really off-putting and&nbsp;unnecessarily&nbsp;complicated. What was wrong with Nano for editing HTML pages on my server?</p>
<p>The guy eventually convinced me to try learning Vim using a program called <strong>vimtutor</strong>. I tried the tutorial. It still seemed arcane and cryptic, but as I worked through it more, I started seeing some crazy possibilities. Vim possesses a succinct and powerful syntax for editing text in a really unusual fashion. I saw the possibilites open up for navigating and manipulating text in powerful ways that had never even&nbsp;occurred&nbsp;to me before. I'll spare you the details, but it was an eye-opening experience. My text editor could be a more powerful tool for accomplishing useful work than I had ever thought was possible.</p>
<p>I'm not here to preach Vim and get you to switch to it, or start yet another holy war with the Emacs crowd. It seems to me that Emacs is a perfectly valid alternative to Vim - I just don't have the mental capacity to learn both editors at once.</p>
<p>But, I do&nbsp;recommend&nbsp;that you try out a powerful text editor - ANY powerful text editor! I think it's an experience that every programmer should at least try. The best contenders right now in my mind are <a href="http://www.vim.org/">Vim</a>, <a href="http://www.gnu.org/software/emacs/">Emacs</a>, and <a href="http://macromates.com/">TextMate</a>.</p>
<p>There are a few reasons why I decided to commit to Vim as my editor of choice:</p>
<ul>
<li><strong>Vim is powerful.</strong> As I have increased my mastery over its complicated set of commands and modes, my efficiency in editing text has risen proportionally. This is great for me as a programmer - the less time it takes me to mechanically edit text, the more time I can spend thinking about and writing code.</li>
<li><strong>Vim is flexible.</strong> Once you speak it's language, you can combine commands to create expressions that accomplish a very specific and complicated text editing tasks in a few keystrokes. Its interoperability with the shell is cool. For instance, it's very easy to use Vim as a lightweight pseudo-IDE for any language that has a command-line compiler or interpreter. It has support for plugins and new syntax rules, which allows the community to contribute rules for all sorts of uncommon languages. If you know a language, there are probably Vim syntax highlighting rules for it!</li>
<li><strong>Vim is ubiquitous.</strong> It's open source, and available on Mac, Linux, and Windows (and many other OSes including BSD!) In fact, any Unix system I've ever used, including Debian 0.91 from 2002 included some form of a Vi editor.</li>
<li><strong>Vim is lightweight.</strong> I think it typically weighs in at around 20 MB. Right now, MacVim is consuming 16.9 MB of memory on my computer and averages about 0-5% of my CPU. This is in contrast to a full-blown IDE like NetBeans, which is 154.8 MB in size, and can take up between 5-30% of my CPU when running and a whopping 329 MB of memory! NetBeans sometimes produces noticeable hangs on my machine.</li>
<li><strong>Vim is deep.</strong> I've never encountered another program with the same amount of commands, modes, etc. This put me off at first, but I've learned over time that each feature is present for a reason, and in mastering a new feature, I unlock new levels of efficiency in using the tool. It's a slow burn - I'd expect that Vim has at least a 10-year, perhaps even a lifetime learning curve. (You can learn the basics of vanilla text editing in a few minutes - I'm talking about the learning curve to fully utilize the tool's powerful features.) I can't spend all my time learning Vim, I need to also focus on learning programming languages, new technologies, etc.</li>
</ul>
<p>I have been using Vim as my primary editor for something like 6 years now, and I am still learning new features every day. I find the time I've put in to learning the editor is really starting to pay off. Recently, a coworker who was watching me edit some HTML remarked, "<strong>Whoa, I thought people only went that fast in movies!</strong>"</p>
<p>Here's what I find lacking in Vim:</p>
<ul>
<li>The learning curve is at times ridiculously steep which can be discouraging. It often takes me months to get enough use out of a feature to remember that it exists, how to use it, and finally how to use it effectively. I think, however, that this is part of the price of having a highly powerful and advanced tool for any sort of craft.</li>
<li>The documentation is dense and in many places seems to assume you are familiar with other aspects of Vim. Considering how massive the feature list of this editor is, that's not always the case. Thankfully links are provided - but I don't always feel like learning an entire new subsystem just to get one feature working! Google is my friend here as it's often more clear to read somebody's blog post than the actual Vim manual.</li>
<li>The scripting language seems clunky. I have no desire to learn yet another hacky Unix scripting language - bash is enough for me! That's okay for now since the handful of Vim plugins I actually want have already been written by someone else. Also, Vim can be downloaded or compiled with support for additional&nbsp;scripting&nbsp;languages such as Python.</li>
<li>Vim supports code completion, which is cool, but it's a real pain in the ass to set up completion for your own code (i.e. getting a list of methods that I can call on an object of a certain class that I wrote, which is a nice feature that some IDEs provide.) I have yet to meet anyone in real life that has actually bothered to do this. It requires setting up a program called <a href="http://en.wikipedia.org/wiki/Ctags">ctags</a> (or <a href="http://ctags.sourceforge.net/">exuberant ctags</a>) and running that every time you want to update your completion rules, which analyzes your code and produces a 'tags' file. Emacs has this exact same issue by the way, it also uses ctags! This is one area where bulky IDE's actually provide enough of a service to warrant their rather poor behavior! However, there is a built-in feature called keyword completion that works without any special set-up and is able to complete words in the current file. This is very handy for referring to variable names, etc.</li>
</ul>
<p>With all of this in mind, I'd like to put forward my current list of qualities that an ideal code editor should have:</p>
<ol>
<li><strong>Powerful</strong> - A code editor should be able to manipulate text in powerful and context-sensitive ways.</li>
<li><strong>Assistive</strong> - A code editor should provide facilities for code completion and inline display of documentation relevant to the code being written.</li>
<li><strong>Multi-language</strong> - A code editor should not tie you to any particular programming language.</li>
<li><strong>Crossplatform</strong> - A code editor should not tie you to any particular&nbsp;operating system.</li>
<li><strong>Plugin architecture </strong>- A code editor should be easily extensible to work with new languages by its user base.</li>
<li><strong>Open source</strong> -&nbsp;A code editor should be easily extensible to work with new operating systems by its user base.</li>
</ol>
<p>How do some editors I know of rank against this rubric?*</p>
<table style="font-size: 11px;">
<tbody>
<tr>
<td></td>
<td>Powerful</td>
<td>Assistive</td>
<td>Multi-language</td>
<td>Crossplatform</td>
<td>Plugin architecture</td>
<td>Open source</td>
</tr>
<tr>
<td>Vim</td>
<td>Yes</td>
<td>Sort of</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Emacs</td>
<td>Yes</td>
<td>Sort of</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>NetBeans</td>
<td>Sort of</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Visual Studio</td>
<td>Sort of</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Xcode</td>
<td>Sort of</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>TextMate</td>
<td>Yes</td>
<td>Sort of</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>TextWrangler</td>
<td>Sort of</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Notepad++</td>
<td>Sort of</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>*This table is highly subjective. I tried to include some popular editors that I haven't personally used much like TextMate and Emacs and assess them by reading about them and talking to people who use them.&nbsp;<a href="http://en.wikipedia.org/wiki/Comparison_of_text_editors">See Wikipedia for a more exhaustive comparison of text editor features</a>.</p>
<p>I was a bit hard on the IDE's listed here. To be fair, most of them support a handful of different languages. However, I don't think they meet the criteria of "should not tie you to any particular&nbsp;language" since a lot of their more useful features such as code completion would not be available in anything other than those languages even if you were to use them as a plain text editor.</p>
<p>There isn't an editor that actually meets all 6 of my criteria. Vim and Emacs come the closest, but the fact that most human beings don't actually have the patience to install and run ctags for code completion makes me rank them down in the "Assistive" category, whereas in the IDE's this is automatic and built-in. I also ranked the IDE's down for "Powerful" because the context-sensitive editing abilities in their default editors are tied to their particular languages, whereas these commands in Vim are generic and work in any language.&nbsp;Also, if you've used Vim, your definition of 'powerful editing' changes and you realize that what are typically considered powerful editing features are weak sauce. :)&nbsp;Emacs gets a pass since it has <a href="http://www.emacswiki.org/emacs/ProgrammingModes">a metric assload of modes</a> for a bunch of different languages.</p>
<p>Other editors such as TextMate seem appealing, but are not crossplatform or open-source. I am a generalist; I write games for Windows, backends for Linux, and utilities for Mac OS X, among other things. Mac is my primary platform at the moment, but I feel like it would be foolish for me to put all my eggs in one basket by tying myself to a text editor whose creators <a href="http://macromates.com/">openly proclaim it will never be ported to any other system</a>.</p>
<p>Another enticing option is the franken-editor... people have actually written plugins for various IDE's that allow a simulated Vi editing mode (<a href="http://jvi.sourceforge.net/">jVi</a>, <a href="http://www.viemu.com/">ViEmu</a>)&nbsp;or in one case, <a href="http://eclim.org/">a real instance of Vim</a> to run inside of the IDE. This actually winds up providing a great mix of editing power and assistive support from the IDE. It's a win for Vim ubiquity since I can re-use my exact same muscle memory for editing within multiple IDEs. However, this scenario is plagued by the same issues that make the IDE fall short of perfect, by tying you to specific languages supported by the base IDE.</p>
<p>To wrap up, I don't think the ideal code editor exists. If you have the good fortune to be coding in a language supported by a decent IDE, that could be the ideal editor for that language, but not others, and you'll pay a friction penalty switching between the IDE editor and whatever other editor you use, unless you're doubly fortunate and there's some sort of plugin to make the IDE work like your other editor or vice versa.</p>
<p>Vim and Emacs are pretty dang good, but fall short of perfect in my eyes since it's such a pain in the ass to set up ctags. If either the Vim or Emacs community was able and willing to bundle this functionality up in a more automatic and integrated way (i.e. not making me compile the damn thing for OSX or force me to ask my sysadmin to install the exuberant ctags RPM in a shared environment,) they just might fit my criteria for perfect code editor. At least until I actually used them and thought up more features I'd want. :)</p>
